# Batch effect adjustment {#adjust}

## Accounting for batch effects

Methods that account for batch effects estimate unknown batch effects through matrix decomposition and / or assign a known or estimated batch as a covariate with linear models. 

### Linear model and linear mixed model

LM and LMM are suitable for known batch effects, and can consider batch x treatment interaction and deal with unbalanced batch x treatment design. But they are univariate and rely on a Gaussian likelihood assumption, which may not apply to zero-inflated microbiome data despite CLR transformation.

We fit a linear model for both sponge and AD data.

```{r}
# Sponge data
sponge.trt_p <- apply(sponge.tss.clr, 2, FUN = function(x){
  res.lm <- lm(x ~ sponge.trt + sponge.batch)
  summary.res = summary(res.lm)
  p = summary.res$coefficients[2,4]
})

sponge.trt_q = p.adjust(sponge.trt_p,method = 'fdr')

# AD data
ad.trt_p <- apply(ad.tss.clr, 2, FUN = function(x){
  res.lm <- lm(x ~ ad.trt + ad.batch)
  summary.res = summary(res.lm)
  p = summary.res$coefficients[2,4]
})

ad.trt_q = p.adjust(ad.trt_p,method = 'fdr')
```

As the batch x treatment design of AD data is unbalaced, we fit a linear mixed model considering batch (cage) as random effects.

```{r, warning=F, message=F,error=FALSE}
# HD data
hd.trt_p <- apply(hd.tss.clr, 2, FUN = function(x){
  res.lmm <- lmer(x ~ hd.trt + (1|hd.batch))
  summary.res = summary(res.lmm)
  p = summary.res$coefficients[2,5]
})

hd.trt_q = p.adjust(hd.trt_p,method = 'fdr')
```

### SVA

SVA can account for unknown batch effects. But it is univariate, relies on a Gaussian likelihood assumption and implicitly introduces a correlation between treatment and batch. 

The *sva* function performs two different steps. First it identifies the number of latent factors that need to be estimated. The number of factors can be estimated using the *num.sv*.

```{r}
# sponge data
sponge.mod = model.matrix(~sponge.trt) # full model
sponge.mod0 = model.matrix(~1,data = sponge.trt) # null model
sponge.sva.n <- num.sv(dat = t(sponge.tss.clr), mod = sponge.mod)
```

Next we apply the *sva* function to estimate the surrogate variables:

```{r}
sponge.sva = sva(t(sponge.tss.clr), sponge.mod, sponge.mod0, n.sv = sponge.sva.n)
```

We include the estimated surrogate variables in both the null and full models. The reason is that we want to adjust for the surrogate variables, so we treat them as adjustment variables that must be included in both models. The *f.pvalue* function is then used to calculate parametric F-test P-values and Q-values (adjusted P-values) for each OTU of sponge data. 

```{r}
sponge.mod.bat = cbind(sponge.mod,sponge.sva$sv)
sponge.mod0.bat = cbind(sponge.mod0,sponge.sva$sv)

sponge.sva.trt_p = f.pvalue(t(sponge.tss.clr),sponge.mod.bat,sponge.mod0.bat)
sponge.sva.trt_q = p.adjust(sponge.sva.trt_p,method="fdr")
```

Now these P-values and Q-values are accounting for surrogate variables (estimated batch effects).

We also apply SVA on both AD and HD data.

```{r}
# ad data
ad.mod = model.matrix(~ad.trt)
ad.mod0 = model.matrix(~1,data = ad.trt)
ad.sva.n <- num.sv(dat = t(ad.tss.clr), mod = ad.mod)
ad.sva = sva(t(ad.tss.clr), ad.mod, ad.mod0, n.sv = ad.sva.n)
ad.mod.bat = cbind(ad.mod,ad.sva$sv)
ad.mod0.bat = cbind(ad.mod0,ad.sva$sv)
ad.sva.trt_p = f.pvalue(t(ad.tss.clr),ad.mod.bat,ad.mod0.bat)
ad.sva.trt_q = p.adjust(ad.sva.trt_p,method="fdr")

# hd data
hd.mod = model.matrix(~hd.trt)
hd.mod0 = model.matrix(~1,data = hd.trt)
hd.sva.n <- num.sv(dat = t(hd.tss.clr), mod = hd.mod)
hd.sva = sva(t(hd.tss.clr), hd.mod, hd.mod0, n.sv = hd.sva.n)
hd.mod.bat = cbind(hd.mod,hd.sva$sv)
hd.mod0.bat = cbind(hd.mod0,hd.sva$sv)
hd.sva.trt_p = f.pvalue(t(hd.tss.clr),hd.mod.bat,hd.mod0.bat)
hd.sva.trt_q = p.adjust(hd.sva.trt_p,method="fdr")
```

### RUV2

RUV2 estimates and accounts for unknown batch effects. But it needs negative control variables that are affected by batch effects but not treatment effects. 

In the real world, we design negative control variables that are not affected by treatment effects only, we are not sure but assume these controls are affected by batch effects. RUV2 can only account for the difference captured by these controls.

Since our three datasets do not have negative control variables, we use a linear model (or linear mixed model) to identify OTUs less likely to be affected by treatment effects as negative controls. 

```{r, warning=F, message=F,error=FALSE}
# sponge data
sponge.nc = sponge.trt_q > 0.05
sponge.ruv2 <- RUV2(Y = sponge.tss.clr, X = sponge.trt, ctl = sponge.nc, k = 3) # k is subjective
sponge.ruv2.trt_p <- sponge.ruv2$p
sponge.ruv2.trt_q <- p.adjust(sponge.ruv2.trt_p,method="fdr")

# AD data
ad.nc = ad.trt_q > 0.05
ad.ruv2 <- RUV2(Y = ad.tss.clr, X = ad.trt, ctl = ad.nc, k = 3) # k is subjective
ad.ruv2.trt_p <- ad.ruv2$p
ad.ruv2.trt_q <- p.adjust(ad.ruv2.trt_p,method="fdr")

# HD data
hd.nc = hd.trt_p > 0.05
hd.ruv2 <- RUV2(Y = hd.tss.clr, X = hd.trt, ctl = hd.nc, k = 3) # k is subjective
hd.ruv2.trt_p <- hd.ruv2$p
hd.ruv2.trt_q <- p.adjust(hd.ruv2.trt_p,method="fdr")

```


### RUV4

```{r, message=F,warning=F,error=F}
# sponge data
sponge.k.obj = getK(Y = sponge.tss.clr, X = sponge.trt, ctl = sponge.nc)
sponge.k = sponge.k.obj$k
sponge.k = ifelse(sponge.k !=0, sponge.k, 1)
sponge.ruv4 <- RUV4(Y = sponge.tss.clr, X = sponge.trt, ctl = sponge.nc, k = sponge.k) 
sponge.ruv4.trt_p <- sponge.ruv4$p
sponge.ruv4.trt_q <- p.adjust(sponge.ruv4.trt_p,method="fdr")

# AD data
ad.k.obj = getK(Y = ad.tss.clr, X = ad.trt, ctl = ad.nc)
ad.k =ad.k.obj$k
ad.k = ifelse(ad.k !=0, ad.k, 1)
ad.ruv4 <- RUV4(Y = ad.tss.clr, X = ad.trt, ctl = ad.nc, k = ad.k) 
ad.ruv4.trt_p <- ad.ruv4$p
ad.ruv4.trt_q <- p.adjust(ad.ruv4.trt_p,method="fdr")

# HD data
hd.k.obj = getK(Y = hd.tss.clr, X = hd.trt, ctl = hd.nc)
hd.k = hd.k.obj$k
hd.k = ifelse(hd.k !=0, hd.k, 1)
hd.ruv4 <- RUV4(Y = hd.tss.clr, X = hd.trt, ctl = hd.nc, k = hd.k) 
hd.ruv4.trt_p <- hd.ruv4$p
hd.ruv4.trt_q <- p.adjust(hd.ruv4.trt_p,method="fdr")
```


## Correcting for batch effects

### BMC (batch mean centering)

```{r}
# Sponge data
sponge.b1 = scale(sponge.tss.clr[sponge.batch== 1,],center = TRUE, scale = FALSE)
sponge.b2 = scale(sponge.tss.clr[sponge.batch== 2,],center = TRUE, scale = FALSE)
sponge.bmc = rbind(sponge.b1,sponge.b2)
sponge.bmc = sponge.bmc[rownames(sponge.tss.clr),]

##############
# AD data
ad.b1 = scale(ad.tss.clr[ad.batch=="09/04/2015",],center = TRUE, scale = FALSE)
ad.b2 = scale(ad.tss.clr[ad.batch=="14/04/2016",],center = TRUE, scale = FALSE)
ad.b3 = scale(ad.tss.clr[ad.batch=="14/11/2016",],center = TRUE, scale = FALSE)
ad.b4 = scale(ad.tss.clr[ad.batch=="01/07/2016",],center = TRUE, scale = FALSE)
ad.b5 = scale(ad.tss.clr[ad.batch=="21/09/2017",],center = TRUE, scale = FALSE)
ad.bmc = rbind(ad.b1,ad.b2,ad.b3,ad.b4,ad.b5)
ad.bmc = ad.bmc[rownames(ad.tss.clr),]
```

### ComBat

```{r}
# Sponge data
sponge.combat <- t(ComBat(t(sponge.tss.clr),batch=sponge.batch,mod = sponge.mod,par.prior=F,prior.plots = F))

##############
# AD data
ad.combat <- t(ComBat(t(ad.tss.clr),batch=ad.batch,mod = ad.mod, par.prior=F,prior.plots = F))
```


### removeBatchEffect

```{r}
# Sponge data
sponge.limma <- t(removeBatchEffect(t(sponge.tss.clr),batch = sponge.batch,design = sponge.mod))

#############
ad.limma <- t(removeBatchEffect(t(ad.tss.clr),batch = ad.batch,design = ad.mod))
```

### FAbatch

FAbatch is unable to converge on both sponge data and AD data. This may influence the effect of batch correction.

```{r, message=F,warning=F,error=F}
# sponge data
sponge.fabatch.obj = fabatch(x = sponge.tss.clr,y = as.factor(as.numeric(sponge.trt)), batch = sponge.batch)
sponge.fabatch <- sponge.fabatch.obj$xadj

# ad data
ad.fabatch.obj = fabatch(x = ad.tss.clr,y = as.factor(as.numeric(ad.trt)), batch = as.factor(as.numeric(ad.batch)))
ad.fabatch <- ad.fabatch.obj$xadj
```


### percentile normalisation

```{r}
sponge.percentile = percentile_norm(data = sponge.tss, batch = sponge.batch, trt = sponge.trt)

# ad data
ad.percentile = percentile_norm(data = ad.tss, batch = ad.batch, trt = ad.trt)
```


### SVD-based method

```{r}
#################
# sponge data
sponge.sd = apply(sponge.tss.clr,2,sd)
sponge.mean = apply(sponge.tss.clr,2,mean)
X.sponge = scale(sponge.tss.clr,center = T,scale = T)

m.sponge = crossprod(X.sponge)
m.svd.sponge = svd(m.sponge)
barplot(m.svd.sponge$d)

a1.sponge = m.svd.sponge$u[,1]
b1.sponge = m.svd.sponge$v[,1]

# component 1
t1.sponge = X.sponge %*% a1.sponge / drop(sqrt(crossprod(a1.sponge)))
c1.sponge = crossprod(X.sponge, t1.sponge) / drop(crossprod(t1.sponge))
defl.matrix_svd1.sponge  = X.sponge - t1.sponge %*% t(c1.sponge)

# #
sponge.svd = defl.matrix_svd1.sponge
sponge.svd[1:nrow(sponge.svd),1:ncol(sponge.svd)] = NA
for(i in 1:ncol(defl.matrix_svd1.sponge)){
  for(j in 1:nrow(defl.matrix_svd1.sponge)){
    sponge.svd[j,i] = defl.matrix_svd1.sponge[j,i]*sponge.sd[i] + sponge.mean[i]
  }
}

#####################
# ad data
ad.sd = apply(ad.tss.clr,2,sd)
ad.mean = apply(ad.tss.clr,2,mean)
X.ad = scale(ad.tss.clr,center = T,scale = T)

m.ad = crossprod(X.ad)
m.svd.ad = svd(m.ad)
barplot(m.svd.ad$d)

a1.ad = m.svd.ad$u[,1]
b1.ad = m.svd.ad$v[,1]

# component 1
t1.ad = X.ad %*% a1.ad / drop(sqrt(crossprod(a1.ad)))
c1.ad = crossprod(X.ad, t1.ad) / drop(crossprod(t1.ad))
defl.matrix_svd1.ad  = X.ad - t1.ad %*% t(c1.ad)

# #
ad.svd = defl.matrix_svd1.ad
ad.svd[1:nrow(ad.svd),1:ncol(ad.svd)] = NA
for(i in 1:ncol(defl.matrix_svd1.ad)){
  for(j in 1:nrow(defl.matrix_svd1.ad)){
    ad.svd[j,i] = defl.matrix_svd1.ad[j,i]*ad.sd[i] + ad.mean[i]
  }
}

```


### RUVIII

RUVIII needs technical sample replicates and negative control variables. As only AD data have sample replicates, RUVIII is only applied on AD data. We use linear model to find variables with less probability of treatment effects, and these variables are treated as negative control variables to fit the assumptions of RUVIII.

```{r}
#####################
# ad data only
replicates.ad = ad.metadata$sample_name.data.extraction
replicates.ad.matrix = replicate.matrix(replicates.ad)

p.ad = matrix(NA,nrow = 2, ncol = ncol(ad.tss.clr))
rownames(p.ad) = c('ad.trt','ad.batch')
colnames(p.ad) = colnames(ad.tss.clr)
for(i in 1:ncol(ad.tss.clr)){
  res = lm(ad.tss.clr[,i] ~ ad.trt + ad.batch)
  summ.res = summary(res)
  anova.res = anova(res)
  p.ad[1,i] = anova.res$`Pr(>F)`[1]
  p.ad[2,i] = anova.res$`Pr(>F)`[2]
}

p.adj.ad = apply(p.ad,1,p.adjust,method = 'fdr')
p.adj.ad1 = sort(p.adj.ad[,1],decreasing = T)
nc.otu1 = names(p.adj.ad1[1:75]) #negative control genes need be equal or more than samples
nc1 = rep(FALSE, ncol(ad.tss.clr))
names(nc1) = colnames(ad.tss.clr)
nc1[nc.otu1] = TRUE

ad.ruv <- RUVIII(Y=ad.tss.clr,M = replicates.ad.matrix, ctl = nc1)
rownames(ad.ruv) = rownames(ad.tss.clr)

```

