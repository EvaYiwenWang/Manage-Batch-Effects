# Batch effect adjustment {#adjust}

## Accounting for batch effects

Methods that account for batch effects estimate unknown batch effects through matrix decomposition and / or assign a known or estimated batch as a covariate with linear models. 

### Linear model and linear mixed model

LM and LMM are suitable for known batch effects, and can consider batch x treatment interaction and deal with unbalanced batch x treatment design. But they are univariate and rely on a Gaussian likelihood assumption, which may not apply to zero-inflated microbiome data despite CLR transformation.

We fit a linear model for both sponge and AD data.

```{r}
# Sponge data
sponge.trt_p <- apply(sponge.tss.clr, 2, FUN = function(x){
  res.lm <- lm(x ~ sponge.trt + sponge.batch)
  summary.res = summary(res.lm)
  p = summary.res$coefficients[2,4]
})

sponge.trt_q = p.adjust(sponge.trt_p,method = 'fdr')

# AD data
ad.trt_p <- apply(ad.tss.clr, 2, FUN = function(x){
  res.lm <- lm(x ~ ad.trt + ad.batch)
  summary.res = summary(res.lm)
  p = summary.res$coefficients[2,4]
})

ad.trt_q = p.adjust(ad.trt_p,method = 'fdr')
```

As the batch x treatment design of AD data is unbalaced, we fit a linear mixed model considering batch (cage) as random effects.

```{r, warning=F, message=F,error=FALSE}
# HD data
hd.trt_p <- apply(hd.tss.clr, 2, FUN = function(x){
  res.lmm <- lmer(x ~ hd.trt + (1|hd.batch))
  summary.res = summary(res.lmm)
  p = summary.res$coefficients[2,5]
})

hd.trt_q = p.adjust(hd.trt_p,method = 'fdr')
```

### SVA

SVA can account for unknown batch effects. But it is univariate, relies on a Gaussian likelihood assumption and implicitly introduces a correlation between treatment and batch. 

The *sva* function performs two different steps. First it identifies the number of latent factors that need to be estimated. The number of factors can be estimated using the *num.sv*.

```{r}
# sponge data
sponge.mod = model.matrix(~sponge.trt) # full model
sponge.mod0 = model.matrix(~1,data = sponge.trt) # null model
sponge.sva.n <- num.sv(dat = t(sponge.tss.clr), mod = sponge.mod)
```

Next we apply the *sva* function to estimate the surrogate variables:

```{r}
sponge.sva = sva(t(sponge.tss.clr), sponge.mod, sponge.mod0, n.sv = sponge.sva.n)
```

We include the estimated surrogate variables in both the null and full models. The reason is that we want to adjust for the surrogate variables, so we treat them as adjustment variables that must be included in both models. The *f.pvalue* function is then used to calculate parametric F-test P-values and Q-values (adjusted P-values) for each OTU of sponge data. 

```{r}
sponge.mod.bat = cbind(sponge.mod,sponge.sva$sv)
sponge.mod0.bat = cbind(sponge.mod0,sponge.sva$sv)

sponge.sva.trt_p = f.pvalue(t(sponge.tss.clr),sponge.mod.bat,sponge.mod0.bat)
sponge.sva.trt_q = p.adjust(sponge.sva.trt_p,method="fdr")
```

Now these P-values and Q-values are accounting for surrogate variables (estimated batch effects).

We also apply SVA on both AD and HD data.

```{r}
# ad data
ad.mod = model.matrix(~ad.trt)
ad.mod0 = model.matrix(~1,data = ad.trt)
ad.sva.n <- num.sv(dat = t(ad.tss.clr), mod = ad.mod)
ad.sva = sva(t(ad.tss.clr), ad.mod, ad.mod0, n.sv = ad.sva.n)
ad.mod.bat = cbind(ad.mod,ad.sva$sv)
ad.mod0.bat = cbind(ad.mod0,ad.sva$sv)
ad.sva.trt_p = f.pvalue(t(ad.tss.clr),ad.mod.bat,ad.mod0.bat)
ad.sva.trt_q = p.adjust(ad.sva.trt_p,method="fdr")

# hd data
hd.mod = model.matrix(~hd.trt)
hd.mod0 = model.matrix(~1,data = hd.trt)
hd.sva.n <- num.sv(dat = t(hd.tss.clr), mod = hd.mod)
hd.sva = sva(t(hd.tss.clr), hd.mod, hd.mod0, n.sv = hd.sva.n)
hd.mod.bat = cbind(hd.mod,hd.sva$sv)
hd.mod0.bat = cbind(hd.mod0,hd.sva$sv)
hd.sva.trt_p = f.pvalue(t(hd.tss.clr),hd.mod.bat,hd.mod0.bat)
hd.sva.trt_q = p.adjust(hd.sva.trt_p,method="fdr")
```

### RUV2

RUV2 estimates and accounts for unknown batch effects. But it needs negative control variables that are affected by batch effects but not treatment effects. 

In the real world, we design negative control variables that are not affected by treatment effects only, we are not sure but assume these controls are affected by batch effects. RUV2 can only account for the difference captured by these controls.

Since our three datasets do not have negative control variables, we use a linear model (or linear mixed model) to identify OTUs less likely to be affected by treatment effects as negative controls to fit the assumptions. The P-values of treatment effects calculated in section 'Linear model and linear mixed model' are therefore used here.

**Note:** it is not a optimal way to obtain negative control variables like what we did. Negative control variables should be known and designed before the experiment. The reason we obtained controls using this way is just to fit the assumption and demonstrate hwo to use RUV series.

```{r}
# sponge data
sponge.nc = sponge.trt_q > 0.05

# AD data
ad.nc = ad.trt_q > 0.05

# HD data
hd.nc = hd.trt_p > 0.05
```

We then apply the *RUV2* function. This function needs to specify the number of unwanted factors (components of negative controls). We therefore specify k = 3, but the number is very subjective and can be changed to any number. After that, we extract the P-values of treatment effects considering unwanted batch effects and then Q-values after FDR adjustment.

```{r, warning=F, message=F,error=FALSE}
# sponge data
sponge.ruv2 <- RUV2(Y = sponge.tss.clr, X = sponge.trt, ctl = sponge.nc, k = 3) # k is subjective
sponge.ruv2.trt_p <- sponge.ruv2$p
sponge.ruv2.trt_q <- p.adjust(sponge.ruv2.trt_p,method="fdr")

# AD data
ad.ruv2 <- RUV2(Y = ad.tss.clr, X = ad.trt, ctl = ad.nc, k = 3) # k is subjective
ad.ruv2.trt_p <- ad.ruv2$p
ad.ruv2.trt_q <- p.adjust(ad.ruv2.trt_p,method="fdr")

# HD data
hd.ruv2 <- RUV2(Y = hd.tss.clr, X = hd.trt, ctl = hd.nc, k = 3) # k is subjective
hd.ruv2.trt_p <- hd.ruv2$p
hd.ruv2.trt_q <- p.adjust(hd.ruv2.trt_p,method="fdr")
```


### RUV4

RUV4 is an updated version of RUV2 that uses negative control variables and the residual matrix that has no treatment effect to estimate unwanted batch effects.

*RUV4* also needs to specify the number of unwanted factors as *RUV2*, and here we use a function called *getK* to estimate this number. This function is only for *RUV4* and the estimated k is not always suitable. If the estimated k is 0, k can be forced to 1 and still to account for unwanted variation captured from negative controls. 

```{r, message=F,warning=F,error=F}
# sponge data
sponge.k.obj = getK(Y = sponge.tss.clr, X = sponge.trt, ctl = sponge.nc)
sponge.k = sponge.k.obj$k
sponge.k = ifelse(sponge.k !=0, sponge.k, 1)
sponge.ruv4 <- RUV4(Y = sponge.tss.clr, X = sponge.trt, ctl = sponge.nc, k = sponge.k) 
sponge.ruv4.trt_p <- sponge.ruv4$p
sponge.ruv4.trt_q <- p.adjust(sponge.ruv4.trt_p,method="fdr")

# AD data
ad.k.obj = getK(Y = ad.tss.clr, X = ad.trt, ctl = ad.nc)
ad.k =ad.k.obj$k
ad.k = ifelse(ad.k !=0, ad.k, 1)
ad.ruv4 <- RUV4(Y = ad.tss.clr, X = ad.trt, ctl = ad.nc, k = ad.k) 
ad.ruv4.trt_p <- ad.ruv4$p
ad.ruv4.trt_q <- p.adjust(ad.ruv4.trt_p,method="fdr")

# HD data
hd.k.obj = getK(Y = hd.tss.clr, X = hd.trt, ctl = hd.nc)
hd.k = hd.k.obj$k
hd.k = ifelse(hd.k !=0, hd.k, 1)
hd.ruv4 <- RUV4(Y = hd.tss.clr, X = hd.trt, ctl = hd.nc, k = hd.k) 
hd.ruv4.trt_p <- hd.ruv4$p
hd.ruv4.trt_q <- p.adjust(hd.ruv4.trt_p,method="fdr")
```


## Correcting for batch effects

### BMC (batch mean centering)

We centers data within a batch across all variables. As a result, each batch mean is standardised to zero. The disadvantages of BMC are it is univariate and not optimal for non-Gaussian distributed microbiome data.

```{r}
# Sponge data
sponge.b1 = scale(sponge.tss.clr[sponge.batch== 1,],center = TRUE, scale = FALSE)
sponge.b2 = scale(sponge.tss.clr[sponge.batch== 2,],center = TRUE, scale = FALSE)
sponge.bmc = rbind(sponge.b1,sponge.b2)
sponge.bmc = sponge.bmc[rownames(sponge.tss.clr),]

##############
# AD data
ad.b1 = scale(ad.tss.clr[ad.batch=="09/04/2015",],center = TRUE, scale = FALSE)
ad.b2 = scale(ad.tss.clr[ad.batch=="14/04/2016",],center = TRUE, scale = FALSE)
ad.b3 = scale(ad.tss.clr[ad.batch=="14/11/2016",],center = TRUE, scale = FALSE)
ad.b4 = scale(ad.tss.clr[ad.batch=="01/07/2016",],center = TRUE, scale = FALSE)
ad.b5 = scale(ad.tss.clr[ad.batch=="21/09/2017",],center = TRUE, scale = FALSE)
ad.bmc = rbind(ad.b1,ad.b2,ad.b3,ad.b4,ad.b5)
ad.bmc = ad.bmc[rownames(ad.tss.clr),]
```

### ComBat

ComBat works on known and systematic batch effects. If the treatment information is known, the option *mod* can be fitted with a full model having treatment informationn to efficiently maintain enough treatment variation, like what we do here on sponge and AD data. The *mod* can also be NULL if the treatment information is unknown. 

```{r}
# Sponge data
sponge.combat <- t(ComBat(t(sponge.tss.clr),batch=sponge.batch,mod = sponge.mod,par.prior=F,prior.plots = F))

##############
# AD data
ad.combat <- t(ComBat(t(ad.tss.clr),batch=ad.batch,mod = ad.mod, par.prior=F,prior.plots = F))
```


### removeBatchEffect

*removeBatchEffect* is a function implemented in the LIMMA package that fits a linear model for each variable given a series of conditions as explanatory variables, including the batch effect and treatment effect. Contrary to a standard linear or linear mixed models (see section 'linear model and linear mixed model') that simultaneously estimate treatment and batch effects, *removeBatchEffect* subtracts the batch effect from the original data, resulting in a residual matrix that contains any and only treatment effect. The option *design* is the same as option *mod* in ComBat.

```{r}
# Sponge data
sponge.limma <- t(removeBatchEffect(t(sponge.tss.clr),batch = sponge.batch,design = sponge.mod))

#############
ad.limma <- t(removeBatchEffect(t(ad.tss.clr),batch = ad.batch,design = ad.mod))
```

### FAbatch

FAbatch is a combination of location-scale adjustment and factor analysis. We fit *y* with the treatment information and *batch* with batch information. Since this method only accepts numeric variables, the levels of variables are changed to be numeric (e.g. '1', '2' and so on). However, FAbatch is unable to converge on both sponge data and AD data. This may influence the effect of batch correction. We therefore do not compare the results from FAbatch with those from other methods.

```{r, message=F,warning=F,error=F}
# sponge data
sponge.fabatch.obj = fabatch(x = sponge.tss.clr,y = as.factor(as.numeric(sponge.trt)), batch = sponge.batch)
sponge.fabatch <- sponge.fabatch.obj$xadj

# ad data
ad.fabatch.obj = fabatch(x = ad.tss.clr,y = as.factor(as.numeric(ad.trt)), batch = as.factor(as.numeric(ad.batch)))
ad.fabatch <- ad.fabatch.obj$xadj
```


### percentile normalisation

Percentile normalisation (PN) is developed for microbiome data integration. For each batch, it transforms the relative abundance of control samples to their own percentiles while converting the relative abundance of case samples into the percentiles of their corresponding control distribution. The method thus only applies to case-control studies, and may lose a large amount of information as it uses percentiles rather than the original values.

```{r}
sponge.percentile = percentile_norm(data = sponge.tss, batch = sponge.batch, trt = sponge.trt)

# ad data
ad.percentile = percentile_norm(data = ad.tss, batch = ad.batch, trt = ad.trt)
```


### SVD-based method

We center and scale the data before SVD. After SVD, we deflate the first component, which has the highest variation and is assumed to related to batch effects.

```{r}
#################
# sponge data
sponge.sd = apply(sponge.tss.clr,2,sd)
sponge.mean = apply(sponge.tss.clr,2,mean)
sponge.X = scale(sponge.tss.clr,center = T,scale = T)

sponge.m = crossprod(sponge.X)
sponge.m.svd = svd(sponge.m)
#barplot(sponge.m.svd$d)

sponge.a1 = sponge.m.svd$u[,1]
sponge.b1 = sponge.m.svd$v[,1]

# component 1
sponge.t1 = sponge.X %*% sponge.a1 / drop(sqrt(crossprod(sponge.a1)))
sponge.c1 = crossprod(sponge.X, sponge.t1) / drop(crossprod(sponge.t1))
sponge.svd.defl.matrix1  = sponge.X - sponge.t1 %*% t(sponge.c1)

## add back mean and variance
sponge.svd = sponge.svd.defl.matrix1
sponge.svd[1:nrow(sponge.svd),1:ncol(sponge.svd)] = NA
for(i in 1:ncol(sponge.svd.defl.matrix1)){
  for(j in 1:nrow(sponge.svd.defl.matrix1)){
    sponge.svd[j,i] = sponge.svd.defl.matrix1[j,i]*sponge.sd[i] + sponge.mean[i]
  }
}

#####################
# ad data
ad.sd = apply(ad.tss.clr,2,sd)
ad.mean = apply(ad.tss.clr,2,mean)
ad.X = scale(ad.tss.clr,center = T,scale = T)

ad.m = crossprod(ad.X)
ad.m.svd = svd(ad.m)
barplot(ad.m.svd$d)

ad.a1 = ad.m.svd$u[,1]
ad.b1 = ad.m.svd$v[,1]

# component 1
ad.t1 = ad.X %*% ad.a1 / drop(sqrt(crossprod(ad.a1)))
ad.c1 = crossprod(ad.X, ad.t1) / drop(crossprod(ad.t1))
ad.svd.defl.matrix1  = ad.X - ad.t1 %*% t(ad.c1)

# #
ad.svd = ad.svd.defl.matrix1
ad.svd[1:nrow(ad.svd),1:ncol(ad.svd)] = NA
for(i in 1:ncol(ad.svd.defl.matrix1)){
  for(j in 1:nrow(ad.svd.defl.matrix1)){
    ad.svd[j,i] = ad.svd.defl.matrix1[j,i]*ad.sd[i] + ad.mean[i]
  }
}

```


### RUVIII

RUVIII needs not only negative control variables as RUV2 and RUV4, but also technical sample replicates. As only AD data have sample replicates, RUVIII is only applied on AD data. 

In contrast to RUV2 and RUV4, RUVIII is a multivariate method that accounts for the dependency between microbial variables, but it is currently limited to the correction of technical and computational sources of batch effects. 

**Note:** RUVIII requires the number of negative control variables to be larger than the sample size in order to fully use the sample information.

```{r}
#####################
# ad data only
ad.replicates = ad.metadata$sample_name.data.extraction
ad.replicates.matrix = replicate.matrix(ad.replicates)

ad.ruvIII <- RUVIII(Y=ad.tss.clr,M = ad.replicates.matrix, ctl = ad.nc)
rownames(ad.ruvIII) = rownames(ad.tss.clr)
```

