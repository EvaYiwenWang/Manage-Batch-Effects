<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Chapter 3 Batch effect adjustment | Managing Batch Effects in Microbiome Data</title>
  <meta name="description" content="Vignette for paper ‘Managing Batch Effects in Microbiome Data’">
  <meta name="generator" content="bookdown  and GitBook 2.6.7">

  <meta property="og:title" content="Chapter 3 Batch effect adjustment | Managing Batch Effects in Microbiome Data" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Vignette for paper ‘Managing Batch Effects in Microbiome Data’" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 3 Batch effect adjustment | Managing Batch Effects in Microbiome Data" />
  
  <meta name="twitter:description" content="Vignette for paper ‘Managing Batch Effects in Microbiome Data’" />
  

<meta name="author" content="Yiwen Wang">


<meta name="date" content="2019-06-21">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="detect.html">
<link rel="next" href="eval.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Batch Effects Management</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Examples of microbiome studies with batch effects</a><ul>
<li class="chapter" data-level="1.1" data-path="index.html"><a href="index.html#study-description"><i class="fa fa-check"></i><b>1.1</b> Study description</a><ul>
<li class="chapter" data-level="1.1.1" data-path="index.html"><a href="index.html#sponge-aplysina-aerophoba-study"><i class="fa fa-check"></i><b>1.1.1</b> Sponge <em>Aplysina aerophoba</em> study</a></li>
<li class="chapter" data-level="1.1.2" data-path="index.html"><a href="index.html#anaerobic-digestion-study"><i class="fa fa-check"></i><b>1.1.2</b> Anaerobic digestion study</a></li>
<li class="chapter" data-level="1.1.3" data-path="index.html"><a href="index.html#huntingtons-disease-study"><i class="fa fa-check"></i><b>1.1.3</b> Huntington’s disease study</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="index.html"><a href="index.html#data-processing"><i class="fa fa-check"></i><b>1.2</b> Data processing</a><ul>
<li class="chapter" data-level="1.2.1" data-path="index.html"><a href="index.html#prefiltering"><i class="fa fa-check"></i><b>1.2.1</b> Prefiltering</a></li>
<li class="chapter" data-level="1.2.2" data-path="index.html"><a href="index.html#total-sum-scaling"><i class="fa fa-check"></i><b>1.2.2</b> Total sum scaling</a></li>
<li class="chapter" data-level="1.2.3" data-path="index.html"><a href="index.html#centered-log-ratio-transformation"><i class="fa fa-check"></i><b>1.2.3</b> Centered log-ratio transformation</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="detect.html"><a href="detect.html"><i class="fa fa-check"></i><b>2</b> Batch effect detection</a><ul>
<li class="chapter" data-level="2.1" data-path="detect.html"><a href="detect.html#principal-component-analysis-pca-with-density-plot-per-component"><i class="fa fa-check"></i><b>2.1</b> Principal component analysis (PCA) with density plot per component</a></li>
<li class="chapter" data-level="2.2" data-path="detect.html"><a href="detect.html#density-plot-and-box-plot"><i class="fa fa-check"></i><b>2.2</b> Density plot and box plot</a></li>
<li class="chapter" data-level="2.3" data-path="detect.html"><a href="detect.html#rle-plots"><i class="fa fa-check"></i><b>2.3</b> RLE plots</a></li>
<li class="chapter" data-level="2.4" data-path="detect.html"><a href="detect.html#heatmap"><i class="fa fa-check"></i><b>2.4</b> Heatmap</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="adjust.html"><a href="adjust.html"><i class="fa fa-check"></i><b>3</b> Batch effect adjustment</a><ul>
<li class="chapter" data-level="3.1" data-path="adjust.html"><a href="adjust.html#accounting-for-batch-effects"><i class="fa fa-check"></i><b>3.1</b> Accounting for batch effects</a><ul>
<li class="chapter" data-level="3.1.1" data-path="adjust.html"><a href="adjust.html#linear-model-and-linear-mixed-model"><i class="fa fa-check"></i><b>3.1.1</b> Linear model and linear mixed model</a></li>
<li class="chapter" data-level="3.1.2" data-path="adjust.html"><a href="adjust.html#sva"><i class="fa fa-check"></i><b>3.1.2</b> SVA</a></li>
<li class="chapter" data-level="3.1.3" data-path="adjust.html"><a href="adjust.html#ruv2"><i class="fa fa-check"></i><b>3.1.3</b> RUV2</a></li>
<li class="chapter" data-level="3.1.4" data-path="adjust.html"><a href="adjust.html#ruv4"><i class="fa fa-check"></i><b>3.1.4</b> RUV4</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="adjust.html"><a href="adjust.html#correcting-for-batch-effects"><i class="fa fa-check"></i><b>3.2</b> Correcting for batch effects</a><ul>
<li class="chapter" data-level="3.2.1" data-path="adjust.html"><a href="adjust.html#bmc-batch-mean-centering"><i class="fa fa-check"></i><b>3.2.1</b> BMC (batch mean centering)</a></li>
<li class="chapter" data-level="3.2.2" data-path="adjust.html"><a href="adjust.html#combat"><i class="fa fa-check"></i><b>3.2.2</b> ComBat</a></li>
<li class="chapter" data-level="3.2.3" data-path="adjust.html"><a href="adjust.html#removebatcheffect"><i class="fa fa-check"></i><b>3.2.3</b> removeBatchEffect</a></li>
<li class="chapter" data-level="3.2.4" data-path="adjust.html"><a href="adjust.html#fabatch"><i class="fa fa-check"></i><b>3.2.4</b> FAbatch</a></li>
<li class="chapter" data-level="3.2.5" data-path="adjust.html"><a href="adjust.html#percentile-normalisation"><i class="fa fa-check"></i><b>3.2.5</b> percentile normalisation</a></li>
<li class="chapter" data-level="3.2.6" data-path="adjust.html"><a href="adjust.html#svd-based-method"><i class="fa fa-check"></i><b>3.2.6</b> SVD-based method</a></li>
<li class="chapter" data-level="3.2.7" data-path="adjust.html"><a href="adjust.html#ruviii"><i class="fa fa-check"></i><b>3.2.7</b> RUVIII</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="eval.html"><a href="eval.html"><i class="fa fa-check"></i><b>4</b> Methods evaluation</a><ul>
<li class="chapter" data-level="4.1" data-path="eval.html"><a href="eval.html#diagnostic-plots"><i class="fa fa-check"></i><b>4.1</b> Diagnostic plots</a><ul>
<li class="chapter" data-level="4.1.1" data-path="eval.html"><a href="eval.html#principal-component-analysis-pca-with-density-plot-per-component-1"><i class="fa fa-check"></i><b>4.1.1</b> Principal component analysis (PCA) with density plot per component</a></li>
<li class="chapter" data-level="4.1.2" data-path="eval.html"><a href="eval.html#density-plot-and-box-plot-1"><i class="fa fa-check"></i><b>4.1.2</b> Density plot and box plot</a></li>
<li class="chapter" data-level="4.1.3" data-path="eval.html"><a href="eval.html#rle-plots-1"><i class="fa fa-check"></i><b>4.1.3</b> RLE plots</a></li>
<li class="chapter" data-level="4.1.4" data-path="eval.html"><a href="eval.html#heatmap-1"><i class="fa fa-check"></i><b>4.1.4</b> Heatmap</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="eval.html"><a href="eval.html#variance-calculation"><i class="fa fa-check"></i><b>4.2</b> Variance calculation</a><ul>
<li class="chapter" data-level="4.2.1" data-path="eval.html"><a href="eval.html#linear-model-per-variable"><i class="fa fa-check"></i><b>4.2.1</b> Linear model per variable</a></li>
<li class="chapter" data-level="4.2.2" data-path="eval.html"><a href="eval.html#rda"><i class="fa fa-check"></i><b>4.2.2</b> RDA</a></li>
<li class="chapter" data-level="4.2.3" data-path="eval.html"><a href="eval.html#pvca"><i class="fa fa-check"></i><b>4.2.3</b> PVCA</a></li>
<li class="chapter" data-level="4.2.4" data-path="eval.html"><a href="eval.html#silhouette-coefficient"><i class="fa fa-check"></i><b>4.2.4</b> Silhouette coefficient</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="simu.html"><a href="simu.html"><i class="fa fa-check"></i><b>5</b> Simulations of systematic and non-systematic batch effects</a><ul>
<li class="chapter" data-level="5.1" data-path="simu.html"><a href="simu.html#mean5unequal-variance"><i class="fa fa-check"></i><b>5.1</b> Mean=5,unequal variance</a></li>
<li class="chapter" data-level="5.2" data-path="simu.html"><a href="simu.html#mean05unequal-variance"><i class="fa fa-check"></i><b>5.2</b> Mean=0&amp;5,unequal variance</a></li>
<li class="chapter" data-level="5.3" data-path="simu.html"><a href="simu.html#sponge-data"><i class="fa fa-check"></i><b>5.3</b> Sponge data</a></li>
<li class="chapter" data-level="5.4" data-path="simu.html"><a href="simu.html#ad-data"><i class="fa fa-check"></i><b>5.4</b> AD data</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="bibliography.html"><a href="bibliography.html"><i class="fa fa-check"></i>Bibliography</a></li>
<li class="divider"></li>
<li><a href="https://github.com/EvaYiwenWang/vignette" target="blank">Source codes on github</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Managing Batch Effects in Microbiome Data</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="adjust" class="section level1">
<h1><span class="header-section-number">Chapter 3</span> Batch effect adjustment</h1>
<div id="accounting-for-batch-effects" class="section level2">
<h2><span class="header-section-number">3.1</span> Accounting for batch effects</h2>
<p>Methods that account for batch effects estimate unknown batch effects through matrix decomposition and / or assign a known or estimated batch as a covariate with linear models.</p>
<div id="linear-model-and-linear-mixed-model" class="section level3">
<h3><span class="header-section-number">3.1.1</span> Linear model and linear mixed model</h3>
<p>LM and LMM are suitable for known batch effects, and can consider batch x treatment interaction and deal with unbalanced batch x treatment design. But they are univariate and rely on a Gaussian likelihood assumption, which may not apply to zero-inflated microbiome data despite CLR transformation.</p>
<p>We fit a linear model with effect of interest and batch effect for each OTU in both sponge and AD data. The P-value for the regression coefficient associated with the <em>effect of interest</em> in a linear model is then extracted and multiple testing corrected with “FDR”. We name the adjusted P-values as Q-values.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Sponge data</span>
sponge.trt_p &lt;-<span class="st"> </span><span class="kw">apply</span>(sponge.tss.clr, <span class="dv">2</span>, <span class="dt">FUN =</span> <span class="cf">function</span>(x){
  res.lm &lt;-<span class="st"> </span><span class="kw">lm</span>(x <span class="op">~</span><span class="st"> </span>sponge.trt <span class="op">+</span><span class="st"> </span>sponge.batch)
  summary.res &lt;-<span class="st"> </span><span class="kw">summary</span>(res.lm)
  p &lt;-<span class="st"> </span>summary.res<span class="op">$</span>coefficients[<span class="dv">2</span>,<span class="dv">4</span>]
})

sponge.trt_q &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(sponge.trt_p, <span class="dt">method =</span> <span class="st">&#39;fdr&#39;</span>)

<span class="co"># AD data</span>
ad.trt_p &lt;-<span class="st"> </span><span class="kw">apply</span>(ad.tss.clr, <span class="dv">2</span>, <span class="dt">FUN =</span> <span class="cf">function</span>(x){
  res.lm &lt;-<span class="st"> </span><span class="kw">lm</span>(x <span class="op">~</span><span class="st"> </span>ad.trt <span class="op">+</span><span class="st"> </span>ad.batch)
  summary.res &lt;-<span class="st"> </span><span class="kw">summary</span>(res.lm)
  p &lt;-<span class="st"> </span>summary.res<span class="op">$</span>coefficients[<span class="dv">2</span>,<span class="dv">4</span>]
})

ad.trt_q &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(ad.trt_p, <span class="dt">method =</span> <span class="st">&#39;fdr&#39;</span>)</code></pre></div>
<p>As the batch x treatment design of HD data is unbalaced, we fit a linear mixed model considering batch (cage) as random effects.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># HD data</span>
hd.trt_p &lt;-<span class="st"> </span><span class="kw">apply</span>(hd.tss.clr, <span class="dv">2</span>, <span class="dt">FUN =</span> <span class="cf">function</span>(x){
  res.lmm &lt;-<span class="st"> </span><span class="kw">lmer</span>(x <span class="op">~</span><span class="st"> </span>hd.trt <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span><span class="op">|</span>hd.batch))
  summary.res &lt;-<span class="st"> </span><span class="kw">summary</span>(res.lmm)
  p &lt;-<span class="st"> </span>summary.res<span class="op">$</span>coefficients[<span class="dv">2</span>,<span class="dv">5</span>]
})

hd.trt_q &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(hd.trt_p, <span class="dt">method =</span> <span class="st">&#39;fdr&#39;</span>)</code></pre></div>
</div>
<div id="sva" class="section level3">
<h3><span class="header-section-number">3.1.2</span> SVA</h3>
<p>SVA can account for unknown batch effects. But it is univariate, relies on a Gaussian likelihood assumption and implicitly introduces a correlation between treatment and batch.</p>
<p>The <em>sva</em> function performs two different steps. First it identifies the number of latent factors that need to be estimated. The number of factors can be estimated using the function <em>num.sv</em>.</p>
<p>We first fit a full model with effect of interest and a null model with no effect, and use the full model in the function <em>num.sv</em> to estimate the number of latent factors.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sponge data</span>
sponge.mod &lt;-<span class="st"> </span><span class="kw">model.matrix</span>( <span class="op">~</span><span class="st"> </span>sponge.trt) <span class="co"># full model</span>
sponge.mod0 &lt;-<span class="st"> </span><span class="kw">model.matrix</span>( <span class="op">~</span><span class="st"> </span><span class="dv">1</span>,<span class="dt">data =</span> sponge.trt) <span class="co"># null model</span>
sponge.sva.n &lt;-<span class="st"> </span><span class="kw">num.sv</span>(<span class="dt">dat =</span> <span class="kw">t</span>(sponge.tss.clr), <span class="dt">mod =</span> sponge.mod)</code></pre></div>
<p>Next we apply the <em>sva</em> function to estimate the surrogate variables with both full and null models:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sponge.sva &lt;-<span class="st"> </span><span class="kw">sva</span>(<span class="dt">dat =</span> <span class="kw">t</span>(sponge.tss.clr), <span class="dt">mod =</span> sponge.mod, 
                 <span class="dt">mod0 =</span> sponge.mod0, <span class="dt">n.sv =</span> sponge.sva.n)</code></pre></div>
<pre><code>## Number of significant surrogate variables is:  3 
## Iteration (out of 5 ):1  2  3  4  5</code></pre>
<p>We then include the estimated surrogate variables in both the null and full models. The reason is that we want to adjust for the surrogate variables, so we treat them as adjustment variables that must be included in both models. The <em>f.pvalue</em> function is then used to calculate parametric F-test P-values and Q-values (adjusted P-values) for each OTU of sponge data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sponge.mod.bat &lt;-<span class="st"> </span><span class="kw">cbind</span>(sponge.mod, sponge.sva<span class="op">$</span>sv)
sponge.mod0.bat &lt;-<span class="st"> </span><span class="kw">cbind</span>(sponge.mod0, sponge.sva<span class="op">$</span>sv)

sponge.sva.trt_p &lt;-<span class="st"> </span><span class="kw">f.pvalue</span>(<span class="kw">t</span>(sponge.tss.clr), sponge.mod.bat, sponge.mod0.bat)
sponge.sva.trt_q &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(sponge.sva.trt_p, <span class="dt">method=</span><span class="st">&#39;fdr&#39;</span>)</code></pre></div>
<p>Now these P-values and Q-values are accounting for surrogate variables (estimated batch effects).</p>
<p>We also apply SVA on both AD and HD data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># ad data</span>
ad.mod &lt;-<span class="st"> </span><span class="kw">model.matrix</span>( <span class="op">~</span><span class="st"> </span>ad.trt)
ad.mod0 &lt;-<span class="st"> </span><span class="kw">model.matrix</span>( <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">data =</span> ad.trt)
ad.sva.n &lt;-<span class="st"> </span><span class="kw">num.sv</span>(<span class="dt">dat =</span> <span class="kw">t</span>(ad.tss.clr), <span class="dt">mod =</span> ad.mod)
ad.sva &lt;-<span class="st"> </span><span class="kw">sva</span>(<span class="kw">t</span>(ad.tss.clr), ad.mod, ad.mod0, <span class="dt">n.sv =</span> ad.sva.n)</code></pre></div>
<pre><code>## Number of significant surrogate variables is:  6 
## Iteration (out of 5 ):1  2  3  4  5</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ad.mod.bat &lt;-<span class="st"> </span><span class="kw">cbind</span>(ad.mod, ad.sva<span class="op">$</span>sv)
ad.mod0.bat &lt;-<span class="st"> </span><span class="kw">cbind</span>(ad.mod0, ad.sva<span class="op">$</span>sv)
ad.sva.trt_p &lt;-<span class="st"> </span><span class="kw">f.pvalue</span>(<span class="kw">t</span>(ad.tss.clr), ad.mod.bat, ad.mod0.bat)
ad.sva.trt_q &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(ad.sva.trt_p, <span class="dt">method =</span> <span class="st">&#39;fdr&#39;</span>)

<span class="co"># hd data</span>
hd.mod &lt;-<span class="st"> </span><span class="kw">model.matrix</span>( <span class="op">~</span><span class="st"> </span>hd.trt)
hd.mod0 &lt;-<span class="st"> </span><span class="kw">model.matrix</span>( <span class="op">~</span><span class="st"> </span><span class="dv">1</span>,<span class="dt">data =</span> hd.trt)
hd.sva.n &lt;-<span class="st"> </span><span class="kw">num.sv</span>(<span class="dt">dat =</span> <span class="kw">t</span>(hd.tss.clr), <span class="dt">mod =</span> hd.mod)
hd.sva &lt;-<span class="st"> </span><span class="kw">sva</span>(<span class="kw">t</span>(hd.tss.clr), hd.mod, hd.mod0, <span class="dt">n.sv =</span> hd.sva.n)</code></pre></div>
<pre><code>## Number of significant surrogate variables is:  3 
## Iteration (out of 5 ):1  2  3  4  5</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hd.mod.bat &lt;-<span class="st"> </span><span class="kw">cbind</span>(hd.mod, hd.sva<span class="op">$</span>sv)
hd.mod0.bat &lt;-<span class="st"> </span><span class="kw">cbind</span>(hd.mod0, hd.sva<span class="op">$</span>sv)
hd.sva.trt_p &lt;-<span class="st"> </span><span class="kw">f.pvalue</span>(<span class="kw">t</span>(hd.tss.clr), hd.mod.bat, hd.mod0.bat)
hd.sva.trt_q &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(hd.sva.trt_p, <span class="dt">method =</span> <span class="st">&#39;fdr&#39;</span>)</code></pre></div>
</div>
<div id="ruv2" class="section level3">
<h3><span class="header-section-number">3.1.3</span> RUV2</h3>
<p>RUV2 estimates and accounts for unknown batch effects. But it needs negative control variables that are affected by batch effects but not treatment effects.</p>
<p>In the real world, we design negative control variables that are not affected by treatment effects only, we are not sure but assume these controls are affected by batch effects. RUV2 can only account for the difference captured by these controls.</p>
<p>Since our three datasets do not have negative control variables, we use a linear model (or linear mixed model) to identify OTUs that are not affected by treatment, those will be considered as <em>pseudo negative control variables</em> to fit the assumptions of RUV2. The P-values of treatment effects calculated in section ‘linear model and linear mixed model’ are therefore used here.</p>
<p><strong>Note:</strong> it is not an optimal way to use <em>pseudo negative control variables</em>. Negative control variables should be known and designed before the experiment. The reason we obtained controls using this way is just to fit the assumption and demonstrate hwo to use RUV series.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sponge data</span>
sponge.nc &lt;-<span class="st"> </span>sponge.trt_q <span class="op">&gt;</span><span class="st"> </span><span class="fl">0.05</span>

<span class="co"># AD data</span>
ad.nc &lt;-<span class="st"> </span>ad.trt_q <span class="op">&gt;</span><span class="st"> </span><span class="fl">0.05</span>

<span class="co"># HD data</span>
hd.nc &lt;-<span class="st"> </span>hd.trt_p <span class="op">&gt;</span><span class="st"> </span><span class="fl">0.05</span></code></pre></div>
<p><strong>Note:</strong> In HD data, there is no OTU having statistically siginificant difference between genotypes. We use P-values instead of adjusted P-values (Q-values) to set the negative controls, otherwise, all the OTUs would be negative controls.</p>
<p>We then apply the <em>RUV2</em> function. This function needs to specify the number of unwanted factors (components of negative controls). We therefore specify k = 3, but the number is very subjective and can be changed to any number. After that, we extract the P-values of treatment effects considering unwanted batch effects and then Q-values after FDR adjustment.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sponge data</span>
sponge.ruv2 &lt;-<span class="st"> </span><span class="kw">RUV2</span>(<span class="dt">Y =</span> sponge.tss.clr, <span class="dt">X =</span> sponge.trt, 
                    <span class="dt">ctl =</span> sponge.nc, <span class="dt">k =</span> <span class="dv">3</span>) <span class="co"># k is subjective</span>
sponge.ruv2.trt_p &lt;-<span class="st"> </span>sponge.ruv2<span class="op">$</span>p
sponge.ruv2.trt_q &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(sponge.ruv2.trt_p, <span class="dt">method=</span><span class="st">&quot;fdr&quot;</span>)

<span class="co"># AD data</span>
ad.ruv2 &lt;-<span class="st"> </span><span class="kw">RUV2</span>(<span class="dt">Y =</span> ad.tss.clr, <span class="dt">X =</span> ad.trt, 
                <span class="dt">ctl =</span> ad.nc, <span class="dt">k =</span> <span class="dv">3</span>) <span class="co"># k is subjective</span>
ad.ruv2.trt_p &lt;-<span class="st"> </span>ad.ruv2<span class="op">$</span>p
ad.ruv2.trt_q &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(ad.ruv2.trt_p, <span class="dt">method=</span><span class="st">&quot;fdr&quot;</span>)

<span class="co"># HD data</span>
hd.ruv2 &lt;-<span class="st"> </span><span class="kw">RUV2</span>(<span class="dt">Y =</span> hd.tss.clr, <span class="dt">X =</span> hd.trt, 
                <span class="dt">ctl =</span> hd.nc, <span class="dt">k =</span> <span class="dv">3</span>) <span class="co"># k is subjective</span>
hd.ruv2.trt_p &lt;-<span class="st"> </span>hd.ruv2<span class="op">$</span>p
hd.ruv2.trt_q &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(hd.ruv2.trt_p, <span class="dt">method=</span><span class="st">&quot;fdr&quot;</span>)</code></pre></div>
</div>
<div id="ruv4" class="section level3">
<h3><span class="header-section-number">3.1.4</span> RUV4</h3>
<p>RUV4 is an updated version of RUV2 that uses negative control variables and the residual matrix that has no treatment effect to estimate unwanted batch effects.</p>
<p><em>RUV4</em> also needs to specify the number of unwanted factors as <em>RUV2</em>, and here we use a function called <em>getK</em> to estimate this number. This function is only for <em>RUV4</em> and the estimated k is not always suitable. If the estimated k is 0, k can be forced to 1 and still to account for unwanted variation captured from negative controls.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sponge data</span>
sponge.k.obj &lt;-<span class="st"> </span><span class="kw">getK</span>(<span class="dt">Y =</span> sponge.tss.clr, <span class="dt">X =</span> sponge.trt, <span class="dt">ctl =</span> sponge.nc)
sponge.k &lt;-<span class="st"> </span>sponge.k.obj<span class="op">$</span>k
sponge.k &lt;-<span class="st"> </span><span class="kw">ifelse</span>(sponge.k <span class="op">!=</span><span class="dv">0</span>, sponge.k, <span class="dv">1</span>)
sponge.ruv4 &lt;-<span class="st"> </span><span class="kw">RUV4</span>(<span class="dt">Y =</span> sponge.tss.clr, <span class="dt">X =</span> sponge.trt, <span class="dt">ctl =</span> sponge.nc, <span class="dt">k =</span> sponge.k) 
sponge.ruv4.trt_p &lt;-<span class="st"> </span>sponge.ruv4<span class="op">$</span>p
sponge.ruv4.trt_q &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(sponge.ruv4.trt_p, <span class="dt">method=</span><span class="st">&quot;fdr&quot;</span>)

<span class="co"># AD data</span>
ad.k.obj &lt;-<span class="st"> </span><span class="kw">getK</span>(<span class="dt">Y =</span> ad.tss.clr, <span class="dt">X =</span> ad.trt, <span class="dt">ctl =</span> ad.nc)
ad.k &lt;-<span class="st"> </span>ad.k.obj<span class="op">$</span>k
ad.k &lt;-<span class="st"> </span><span class="kw">ifelse</span>(ad.k <span class="op">!=</span><span class="dv">0</span>, ad.k, <span class="dv">1</span>)
ad.ruv4 &lt;-<span class="st"> </span><span class="kw">RUV4</span>(<span class="dt">Y =</span> ad.tss.clr, <span class="dt">X =</span> ad.trt, <span class="dt">ctl =</span> ad.nc, <span class="dt">k =</span> ad.k) 
ad.ruv4.trt_p &lt;-<span class="st"> </span>ad.ruv4<span class="op">$</span>p
ad.ruv4.trt_q &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(ad.ruv4.trt_p, <span class="dt">method=</span><span class="st">&quot;fdr&quot;</span>)

<span class="co"># HD data</span>
hd.k.obj &lt;-<span class="st"> </span><span class="kw">getK</span>(<span class="dt">Y =</span> hd.tss.clr, <span class="dt">X =</span> hd.trt, <span class="dt">ctl =</span> hd.nc)
hd.k &lt;-<span class="st"> </span>hd.k.obj<span class="op">$</span>k
hd.k &lt;-<span class="st"> </span><span class="kw">ifelse</span>(hd.k <span class="op">!=</span><span class="dv">0</span>, hd.k, <span class="dv">1</span>)
hd.ruv4 &lt;-<span class="st"> </span><span class="kw">RUV4</span>(<span class="dt">Y =</span> hd.tss.clr, <span class="dt">X =</span> hd.trt, <span class="dt">ctl =</span> hd.nc, <span class="dt">k =</span> hd.k) 
hd.ruv4.trt_p &lt;-<span class="st"> </span>hd.ruv4<span class="op">$</span>p
hd.ruv4.trt_q &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(hd.ruv4.trt_p, <span class="dt">method=</span><span class="st">&quot;fdr&quot;</span>)</code></pre></div>
</div>
</div>
<div id="correcting-for-batch-effects" class="section level2">
<h2><span class="header-section-number">3.2</span> Correcting for batch effects</h2>
<p>An alternative approach to manage batch effects is to remove batch effects from the original microbiome data, then use the corrected data in any subsequent data analysis. Compared with methods accounting for batch effects, batch effect correction methods are practical and enable broader application in a variety of analyses. However, the methods do not consider the correlation (linear) and interaction (non-linear) between batch and treatment effects and may result in over-adjusted batch effects, statistical power loss, and an inability to detect variables associated with the treatment effect.</p>
<div id="bmc-batch-mean-centering" class="section level3">
<h3><span class="header-section-number">3.2.1</span> BMC (batch mean centering)</h3>
<p>We centers data within a batch across all variables. As a result, each batch mean is standardised to zero. The disadvantages of BMC are it is univariate and not optimal for non-Gaussian distributed microbiome data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Sponge data</span>
sponge.b1 &lt;-<span class="st"> </span><span class="kw">scale</span>(sponge.tss.clr[sponge.batch <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, ], <span class="dt">center =</span> <span class="ot">TRUE</span>, <span class="dt">scale =</span> <span class="ot">FALSE</span>)
sponge.b2 &lt;-<span class="st"> </span><span class="kw">scale</span>(sponge.tss.clr[sponge.batch <span class="op">==</span><span class="st"> </span><span class="dv">2</span>, ], <span class="dt">center =</span> <span class="ot">TRUE</span>, <span class="dt">scale =</span> <span class="ot">FALSE</span>)
sponge.bmc &lt;-<span class="st"> </span><span class="kw">rbind</span>(sponge.b1, sponge.b2)
sponge.bmc &lt;-<span class="st"> </span>sponge.bmc[<span class="kw">rownames</span>(sponge.tss.clr), ]

##############
<span class="co"># AD data</span>
ad.b1 &lt;-<span class="st"> </span><span class="kw">scale</span>(ad.tss.clr[ad.batch <span class="op">==</span><span class="st"> &#39;09/04/2015&#39;</span>, ], <span class="dt">center =</span> <span class="ot">TRUE</span>, <span class="dt">scale =</span> <span class="ot">FALSE</span>)
ad.b2 &lt;-<span class="st"> </span><span class="kw">scale</span>(ad.tss.clr[ad.batch <span class="op">==</span><span class="st"> &#39;14/04/2016&#39;</span>, ], <span class="dt">center =</span> <span class="ot">TRUE</span>, <span class="dt">scale =</span> <span class="ot">FALSE</span>)
ad.b3 &lt;-<span class="st"> </span><span class="kw">scale</span>(ad.tss.clr[ad.batch <span class="op">==</span><span class="st"> &#39;14/11/2016&#39;</span>, ], <span class="dt">center =</span> <span class="ot">TRUE</span>, <span class="dt">scale =</span> <span class="ot">FALSE</span>)
ad.b4 &lt;-<span class="st"> </span><span class="kw">scale</span>(ad.tss.clr[ad.batch <span class="op">==</span><span class="st"> &#39;01/07/2016&#39;</span>, ], <span class="dt">center =</span> <span class="ot">TRUE</span>, <span class="dt">scale =</span> <span class="ot">FALSE</span>)
ad.b5 &lt;-<span class="st"> </span><span class="kw">scale</span>(ad.tss.clr[ad.batch <span class="op">==</span><span class="st"> &#39;21/09/2017&#39;</span>, ], <span class="dt">center =</span> <span class="ot">TRUE</span>, <span class="dt">scale =</span> <span class="ot">FALSE</span>)
ad.bmc &lt;-<span class="st"> </span><span class="kw">rbind</span>(ad.b1, ad.b2, ad.b3, ad.b4, ad.b5)
ad.bmc &lt;-<span class="st"> </span>ad.bmc[<span class="kw">rownames</span>(ad.tss.clr), ]</code></pre></div>
</div>
<div id="combat" class="section level3">
<h3><span class="header-section-number">3.2.2</span> ComBat</h3>
<p>ComBat works on known and systematic batch effects. If the treatment information is known, the option <em>mod</em> can be fitted with a full model having treatment informationn to efficiently maintain enough treatment variation, like what we do here on sponge and AD data. The <em>mod</em> can also be NULL if the treatment information is unknown.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Sponge data</span>
sponge.combat &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">ComBat</span>(<span class="kw">t</span>(sponge.tss.clr), <span class="dt">batch =</span> sponge.batch, 
                          <span class="dt">mod =</span> sponge.mod, <span class="dt">par.prior =</span> F, <span class="dt">prior.plots =</span> F))</code></pre></div>
<pre><code>## Found2batches</code></pre>
<pre><code>## Adjusting for1covariate(s) or covariate level(s)</code></pre>
<pre><code>## Standardizing Data across genes</code></pre>
<pre><code>## Fitting L/S model and finding priors</code></pre>
<pre><code>## Finding nonparametric adjustments</code></pre>
<pre><code>## Adjusting the Data</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">##############
<span class="co"># AD data</span>
ad.combat &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">ComBat</span>(<span class="kw">t</span>(ad.tss.clr), <span class="dt">batch =</span> ad.batch, 
                      <span class="dt">mod =</span> ad.mod, <span class="dt">par.prior =</span> F, <span class="dt">prior.plots =</span> F))</code></pre></div>
<pre><code>## Found5batches</code></pre>
<pre><code>## Adjusting for1covariate(s) or covariate level(s)</code></pre>
<pre><code>## Standardizing Data across genes</code></pre>
<pre><code>## Fitting L/S model and finding priors</code></pre>
<pre><code>## Finding nonparametric adjustments</code></pre>
<pre><code>## Adjusting the Data</code></pre>
</div>
<div id="removebatcheffect" class="section level3">
<h3><span class="header-section-number">3.2.3</span> removeBatchEffect</h3>
<p><em>removeBatchEffect</em> is a function implemented in the LIMMA package that fits a linear model for each variable given a series of conditions as explanatory variables, including the batch effect and treatment effect. Contrary to a standard linear or linear mixed models (see section ‘linear model and linear mixed model’) that simultaneously estimate treatment and batch effects, <em>removeBatchEffect</em> subtracts the batch effect from the original data, resulting in a residual matrix that contains any and only treatment effect. The option <em>design</em> is the same as option <em>mod</em> in ComBat.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Sponge data</span>
sponge.limma &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">removeBatchEffect</span>(<span class="kw">t</span>(sponge.tss.clr), <span class="dt">batch =</span> sponge.batch, 
                                    <span class="dt">design =</span> sponge.mod))

#############
ad.limma &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">removeBatchEffect</span>(<span class="kw">t</span>(ad.tss.clr), <span class="dt">batch =</span> ad.batch, 
                                <span class="dt">design =</span> ad.mod))</code></pre></div>
</div>
<div id="fabatch" class="section level3">
<h3><span class="header-section-number">3.2.4</span> FAbatch</h3>
<p>FAbatch is a combination of location-scale adjustment and factor analysis. We fit <em>y</em> with the treatment information and <em>batch</em> with batch information. Since this method only accepts numeric variables, the levels of variables are changed to be numeric (e.g. ‘1’, ‘2’ and so on). However, FAbatch is unable to converge on both sponge data and AD data. This may influence the effect of batch correction. We therefore do not compare the results from FAbatch with those from other methods.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sponge data</span>
sponge.fabatch.obj &lt;-<span class="st"> </span><span class="kw">fabatch</span>(<span class="dt">x =</span> sponge.tss.clr, 
                             <span class="dt">y =</span> <span class="kw">as.factor</span>(<span class="kw">as.numeric</span>(sponge.trt)), 
                             <span class="dt">batch =</span> sponge.batch)
sponge.fabatch &lt;-<span class="st"> </span>sponge.fabatch.obj<span class="op">$</span>xadj

<span class="co"># ad data</span>
ad.fabatch.obj &lt;-<span class="st"> </span><span class="kw">fabatch</span>(<span class="dt">x =</span> ad.tss.clr, 
                         <span class="dt">y =</span> <span class="kw">as.factor</span>(<span class="kw">as.numeric</span>(ad.trt)), 
                         <span class="dt">batch =</span> <span class="kw">as.factor</span>(<span class="kw">as.numeric</span>(ad.batch)))
ad.fabatch &lt;-<span class="st"> </span>ad.fabatch.obj<span class="op">$</span>xadj</code></pre></div>
</div>
<div id="percentile-normalisation" class="section level3">
<h3><span class="header-section-number">3.2.5</span> percentile normalisation</h3>
<p>Percentile normalisation (PN) is developed for microbiome data integration. For each batch, it transforms the relative abundance of control samples to their own percentiles while converting the relative abundance of case samples into the percentiles of their corresponding control distribution. The method thus only applies to case-control studies, and may lose a large amount of information as it uses percentiles rather than the original values.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sponge.percentile &lt;-<span class="st"> </span><span class="kw">percentile_norm</span>(<span class="dt">data =</span> sponge.tss, <span class="dt">batch =</span> sponge.batch, 
                                    <span class="dt">trt =</span> sponge.trt)

<span class="co"># ad data</span>
ad.percentile &lt;-<span class="st"> </span><span class="kw">percentile_norm</span>(<span class="dt">data =</span> ad.tss, <span class="dt">batch =</span> ad.batch, 
                                <span class="dt">trt =</span> ad.trt)</code></pre></div>
</div>
<div id="svd-based-method" class="section level3">
<h3><span class="header-section-number">3.2.6</span> SVD-based method</h3>
<p>We center and scale the data before SVD. After SVD, we deflate the first component, which has the highest variation and is assumed to related to batch effects.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sponge data</span>
sponge.sd &lt;-<span class="st"> </span><span class="kw">apply</span>(sponge.tss.clr, <span class="dv">2</span>, sd)
sponge.mean &lt;-<span class="st"> </span><span class="kw">apply</span>(sponge.tss.clr, <span class="dv">2</span>, mean)
sponge.X &lt;-<span class="st"> </span><span class="kw">scale</span>(sponge.tss.clr, <span class="dt">center =</span> T, <span class="dt">scale =</span> T)

sponge.m &lt;-<span class="st"> </span><span class="kw">crossprod</span>(sponge.X)
sponge.m.svd &lt;-<span class="st"> </span><span class="kw">svd</span>(sponge.m)
<span class="co">#barplot(sponge.m.svd$d)</span>

sponge.a1 &lt;-<span class="st"> </span>sponge.m.svd<span class="op">$</span>u[ ,<span class="dv">1</span>]
sponge.b1 &lt;-<span class="st"> </span>sponge.m.svd<span class="op">$</span>v[ ,<span class="dv">1</span>]

<span class="co"># component 1</span>
sponge.t1 &lt;-<span class="st"> </span>sponge.X <span class="op">%*%</span><span class="st"> </span>sponge.a1 <span class="op">/</span><span class="st"> </span><span class="kw">drop</span>(<span class="kw">sqrt</span>(<span class="kw">crossprod</span>(sponge.a1)))
sponge.c1 &lt;-<span class="st"> </span><span class="kw">crossprod</span>(sponge.X, sponge.t1) <span class="op">/</span><span class="st"> </span><span class="kw">drop</span>(<span class="kw">crossprod</span>(sponge.t1))
sponge.svd.defl.matrix1  &lt;-<span class="st"> </span>sponge.X <span class="op">-</span><span class="st"> </span>sponge.t1 <span class="op">%*%</span><span class="st"> </span><span class="kw">t</span>(sponge.c1)

## add back mean and variance
sponge.svd &lt;-<span class="st"> </span>sponge.svd.defl.matrix1
sponge.svd[<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(sponge.svd), <span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(sponge.svd)] =<span class="st"> </span><span class="ot">NA</span>
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(sponge.svd.defl.matrix1)){
  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(sponge.svd.defl.matrix1)){
    sponge.svd[j,i] =<span class="st"> </span>sponge.svd.defl.matrix1[j,i]<span class="op">*</span>sponge.sd[i] <span class="op">+</span><span class="st"> </span>sponge.mean[i]
  }
}


<span class="co"># ad data</span>
ad.sd &lt;-<span class="st"> </span><span class="kw">apply</span>(ad.tss.clr, <span class="dv">2</span>, sd)
ad.mean &lt;-<span class="st"> </span><span class="kw">apply</span>(ad.tss.clr, <span class="dv">2</span>, mean)
ad.X &lt;-<span class="st"> </span><span class="kw">scale</span>(ad.tss.clr,<span class="dt">center =</span> T, <span class="dt">scale =</span> T)

ad.m &lt;-<span class="st"> </span><span class="kw">crossprod</span>(ad.X)
ad.m.svd &lt;-<span class="st"> </span><span class="kw">svd</span>(ad.m)
<span class="co">#barplot(ad.m.svd$d)</span>

ad.a1 &lt;-<span class="st"> </span>ad.m.svd<span class="op">$</span>u[ ,<span class="dv">1</span>]
ad.b1 &lt;-<span class="st"> </span>ad.m.svd<span class="op">$</span>v[ ,<span class="dv">1</span>]

<span class="co"># component 1</span>
ad.t1 &lt;-<span class="st"> </span>ad.X <span class="op">%*%</span><span class="st"> </span>ad.a1 <span class="op">/</span><span class="st"> </span><span class="kw">drop</span>(<span class="kw">sqrt</span>(<span class="kw">crossprod</span>(ad.a1)))
ad.c1 &lt;-<span class="st"> </span><span class="kw">crossprod</span>(ad.X, ad.t1) <span class="op">/</span><span class="st"> </span><span class="kw">drop</span>(<span class="kw">crossprod</span>(ad.t1))
ad.svd.defl.matrix1  &lt;-<span class="st"> </span>ad.X <span class="op">-</span><span class="st"> </span>ad.t1 <span class="op">%*%</span><span class="st"> </span><span class="kw">t</span>(ad.c1)


ad.svd &lt;-<span class="st"> </span>ad.svd.defl.matrix1
ad.svd[<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(ad.svd), <span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(ad.svd)] =<span class="st"> </span><span class="ot">NA</span>
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(ad.svd.defl.matrix1)){
  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(ad.svd.defl.matrix1)){
    ad.svd[j,i] =<span class="st"> </span>ad.svd.defl.matrix1[j,i]<span class="op">*</span>ad.sd[i] <span class="op">+</span><span class="st"> </span>ad.mean[i]
  }
}</code></pre></div>
</div>
<div id="ruviii" class="section level3">
<h3><span class="header-section-number">3.2.7</span> RUVIII</h3>
<p>RUVIII needs not only negative control variables as RUV2 and RUV4, but also technical sample replicates. As only AD data have sample replicates, RUVIII is only applied on AD data.</p>
<p>In contrast to RUV2 and RUV4, RUVIII is a multivariate method that accounts for the dependency between microbial variables, but it is currently limited to the correction of technical and computational sources of batch effects.</p>
<p><strong>Note:</strong> RUVIII requires the number of negative control variables to be larger than the sample size in order to fully use the sample information.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># ad data only</span>
ad.replicates &lt;-<span class="st"> </span>ad.metadata<span class="op">$</span>sample_name.data.extraction
ad.replicates.matrix &lt;-<span class="st"> </span><span class="kw">replicate.matrix</span>(ad.replicates)

ad.ruvIII &lt;-<span class="st"> </span><span class="kw">RUVIII</span>(<span class="dt">Y =</span> ad.tss.clr, <span class="dt">M =</span> ad.replicates.matrix, <span class="dt">ctl =</span> ad.nc)
<span class="kw">rownames</span>(ad.ruvIII) &lt;-<span class="st"> </span><span class="kw">rownames</span>(ad.tss.clr)</code></pre></div>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="detect.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="eval.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"download": ["vignette.pdf"],
"toc": {
"collapse": "subsection",
"edit": "https://github.com/EvaYiwenWang/vignette"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
